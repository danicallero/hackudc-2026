---
export interface Props {
  images: { src: string; alt: string }[];
  autoPlayInterval?: number;
}

const { images, autoPlayInterval = 5000 } = Astro.props;
---

<section
  id="image-gallery-container"
  class="py-20 max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 relative"
  style="isolation: isolate;"
>
  <h2
    class="relative z-20 text-3xl sm:text-4xl md:text-5xl font-black uppercase text-center tracking-[0.25em] text-amber-300 drop-shadow-[0_4px_0_#7c3f00] mb-12 sm:mb-16"
  >
    Gallery
  </h2>

  <div class="relative">
    <!-- Ambient background - centered on carousel track, overflows in all directions -->
    <div
      class="absolute pointer-events-none z-0"
      style="left: 50%; top: 50%; transform: translate(-50%, -50%); width: 200%; height: 120%;"
    >
      <div id="ambient-background" class="ambient-container">
        <div class="ambient-overlay"></div>
      </div>
    </div>

    <!-- Gallery track container with controlled height -->
    <div
      class="relative z-10 min-h-[240px] sm:min-h-[320px] md:min-h-[440px] lg:min-h-[540px] flex items-center"
    >
      <div
        class="gallery-track flex gap-3 sm:gap-4 md:gap-6 transition-transform duration-500 ease-out relative w-full"
        id="gallery-track"
        style="will-change: transform;"
      >
        {
          images.map((image, index) => (
            <div class="gallery-item flex-shrink-0 transition-all duration-500">
              <div class="relative group p-1 rounded-xl">
                <img
                  src={image.src}
                  alt={image.alt}
                  class="gallery-img h-[200px] sm:h-[280px] md:h-[400px] lg:h-[500px] w-auto object-cover rounded-lg transition-opacity duration-300"
                  loading="lazy"
                />
                <div class="absolute inset-0 border-2 border-amber-200 rounded-xl opacity-40 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none" />
                <div class="absolute inset-0 bg-gradient-to-br from-amber-300/5 via-transparent to-amber-300/10 rounded-xl pointer-events-none" />
              </div>
            </div>
          ))
        }
      </div>

      <!-- Navigation buttons positioned relative to track container -->
      <button
        type="button"
        class="absolute left-3 sm:left-4 top-1/2 -translate-y-1/2 z-20 w-8 h-8 sm:w-10 sm:h-10 md:w-12 md:h-12 rounded-full border-2 border-amber-200 bg-amber-300/10 backdrop-blur-sm transition-all duration-300 flex items-center justify-center hover:bg-amber-300/30 hover:border-amber-300 hover:scale-110 hover:shadow-[0_0_20px_rgba(252,211,77,0.3)]"
        id="gallery-prev"
        aria-label="Previous image"
      >
        <svg
          class="w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6 text-amber-200"
          fill="none"
          stroke="currentColor"
          stroke-width="2.5"
          viewBox="0 0 24 24"
          aria-hidden="true"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="M15 19l-7-7 7-7"></path>
        </svg>
      </button>

      <button
        type="button"
        class="absolute right-3 sm:right-4 top-1/2 -translate-y-1/2 z-20 w-8 h-8 sm:w-10 sm:h-10 md:w-12 md:h-12 rounded-full border-2 border-amber-200 bg-amber-300/10 backdrop-blur-sm transition-all duration-300 flex items-center justify-center hover:bg-amber-300/30 hover:border-amber-300 hover:scale-110 hover:shadow-[0_0_20px_rgba(252,211,77,0.3)]"
        id="gallery-next"
        aria-label="Next image"
      >
        <svg
          class="w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6 text-amber-200"
          fill="none"
          stroke="currentColor"
          stroke-width="2.5"
          viewBox="0 0 24 24"
          aria-hidden="true"
        >
          <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"
          ></path>
        </svg>
      </button>
    </div>
  </div>
</section>

<style>
  .ambient-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(1.3);
    width: 100%;
    max-width: 1200px;
    height: 100%;
    opacity: 0;
    background-image: linear-gradient(
        180deg,
        rgba(0, 0, 0, 0) 10%,
        rgba(0, 0, 0, 0.3) 40%,
        rgba(0, 0, 0, 0.8) 70%,
        rgba(0, 0, 0, 1) 100%
      ),
      linear-gradient(0deg, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.7) 100%);
    background-position: center;
    background-size: 120%;
    filter: blur(60px) saturate(1.2);
    transition:
      opacity 1.3s ease-out,
      background-size 0.66s ease-in;
  }

  .ambient-container.active {
    opacity: 0.4;
    background-size: 100%;
    transition: opacity 0.33s ease-in;
  }

  .ambient-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    background-position: 100% 100%;
    background-size: 250%;
    filter: brightness(1.1) saturate(0);
    mix-blend-mode: overlay;
    will-change: opacity, background-position;
    animation: shift-background 60s infinite linear alternate;
    animation-play-state: paused;
    transition: opacity 0.66s ease-in;
  }

  .ambient-container.active .ambient-overlay {
    opacity: 0.15;
    animation-play-state: running;
    transition: opacity 1.3s ease-in 1.3s;
  }

  .gallery-img {
    opacity: 0.5;
  }

  /* Mobile and small tablet constraints: never let an image span too wide */
  @media (max-width: 768px) {
    .gallery-img {
      max-width: 88vw;
    }
    /* Ultra-wide images: clamp more aggressively on mobile and small screens */
    .gallery-item.wide .gallery-img {
      max-width: 72vw;
    }
  }

  /* Medium screens: prevent images from taking full viewport width */
  @media (min-width: 769px) and (max-width: 1200px) {
    .gallery-img {
      max-width: 75vw;
    }
    .gallery-item.wide .gallery-img {
      max-width: 60vw;
    }
  }

  /* Large screens: still cap to avoid excessive width */
  @media (min-width: 1201px) {
    .gallery-img {
      max-width: 65vw;
    }
    .gallery-item.wide .gallery-img {
      max-width: 50vw;
    }
  }

  .gallery-item.active .gallery-img {
    opacity: 1;
  }

  @keyframes shift-background {
    0% {
      background-position: 0% 50%;
      background-size: 250%;
    }
    25% {
      background-position: 60% 20%;
      background-size: 300%;
    }
    50% {
      background-position: 100% 50%;
      background-size: 320%;
    }
    75% {
      background-position: 40% 100%;
      background-size: 220%;
    }
    100% {
      background-position: 20% 50%;
      background-size: 300%;
    }
  }
</style>

<script define:vars={{ autoPlayInterval }}>
  class ImageGalleryCarousel {
    constructor(containerId, options = {}) {
      this.container = document.querySelector(`#${containerId}`);
      if (!this.container) return;

      this.track = this.container.querySelector("#gallery-track");
      this.prevBtn = this.container.querySelector("#gallery-prev");
      this.nextBtn = this.container.querySelector("#gallery-next");
      this.ambientBg = this.container.querySelector("#ambient-background");

      if (!this.track || !this.ambientBg) return;

      this.autoPlayInterval = options.autoPlayInterval || 5000;
      this.autoPlayTimer = null;
      this.isInViewport = false;
      this.currentIndex = 0;
      this.isTransitioning = false;

      this.init();
    }

    init() {
      this.cloneImages();
      this.setupEventListeners();
      this.setupIntersectionObserver();
      this.waitForImagesAndStart();
    }

    cloneImages() {
      const items = Array.from(this.track.children);
      this.imageCount = items.length;

      // Prepend clones so that the order at the front matches originals (A',B',C')
      // This ensures the left neighbor of the first original is the last original (C'),
      // avoiding the first image appearing twice side-by-side.
      for (let i = items.length - 1; i >= 0; i--) {
        const clone = items[i].cloneNode(true);
        this.track.insertBefore(clone, this.track.firstChild);
      }

      // Append clones in original order (A,B,C)
      for (let i = 0; i < items.length; i++) {
        const clone = items[i].cloneNode(true);
        this.track.appendChild(clone);
      }

      this.allItems = Array.from(this.track.children);
      this.currentIndex = this.imageCount;
    }

    setupEventListeners() {
      this.prevBtn?.addEventListener("click", () => this.handlePrev());
      this.nextBtn?.addEventListener("click", () => this.handleNext());
      window.addEventListener("resize", () => this.updatePosition(false));

      // Re-center on breakpoint change (mobile <-> desktop)
      const mq = window.matchMedia("(max-width: 639.98px)");
      mq.addEventListener?.("change", () => this.updatePosition(false));
      // Safari fallback
      mq.addListener?.(() => this.updatePosition(false));

      this.track.addEventListener("transitionend", () => {
        this.isTransitioning = false;
      });
    }

    setupIntersectionObserver() {
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            this.isInViewport = entry.isIntersecting;
            if (this.isInViewport) {
              this.startAutoPlay();
            } else {
              this.stopAutoPlay();
            }
          });
        },
        { threshold: 0.3 }
      );

      observer.observe(this.container);
    }

    getGapSize() {
      if (!this.track) return 0;
      const style = window.getComputedStyle(this.track);
      return parseFloat(style.gap) || 0;
    }

    calculateOffset(index, animate = true) {
      if (!this.track?.parentElement) return 0;

      const containerWidth = this.track.parentElement.clientWidth;
      const gap = this.getGapSize();
      // On mobile, reduce the visual offset sensitivity to keep the active image centered cleanly
      let offset = containerWidth / 2;

      for (let i = 0; i < index; i++) {
        const item = this.allItems[i];
        if (item) {
          offset -= item.offsetWidth + gap;
        }
      }

      const currentItem = this.allItems[index];
      if (currentItem) {
        offset -= currentItem.offsetWidth / 2;
      }

      return offset;
    }

    updateAmbientBackground() {
      const actualIndex = this.currentIndex % this.imageCount;
      const currentItem = this.allItems[this.currentIndex];
      const img = currentItem?.querySelector("img");

      if (!img?.src || !this.ambientBg) return;

      const overlay = this.ambientBg.querySelector(".ambient-overlay");
      this.ambientBg.classList.remove("active");

      setTimeout(() => {
        this.ambientBg.style.backgroundImage = `
          linear-gradient(180deg, rgba(0, 0, 0, 0) 30%, rgba(0, 0, 0, 1) 90%),
          linear-gradient(0deg, rgba(0, 0, 0, 0.6) 0%, rgba(0, 0, 0, 0.6) 100%),
          url(${img.src})
        `;

        if (overlay) {
          overlay.style.backgroundImage = `url(${img.src})`;
        }

        this.ambientBg.classList.add("active");
      }, 100);
    }

    updatePosition(animate = true) {
      if (!this.track) return;

      const offset = this.calculateOffset(this.currentIndex, animate);

      if (animate) {
        this.track.style.transition = "transform 0.5s ease-out";
      } else {
        this.track.style.transition = "none";
      }

      this.track.style.transform = `translateX(${offset}px)`;

      this.allItems.forEach((item, idx) => {
        const isActive = idx === this.currentIndex;
        item.classList.toggle("active", isActive);
        item.style.transform = isActive ? "scale(1.05)" : "scale(0.95)";
      });

      this.updateAmbientBackground();
    }

    goToNext() {
      if (this.isTransitioning) return;

      this.isTransitioning = true;
      this.currentIndex++;
      this.updatePosition(true);

      if (this.currentIndex >= this.imageCount * 2) {
        setTimeout(() => {
          this.currentIndex = this.imageCount;
          this.updatePosition(false);
        }, 500);
      }
    }

    goToPrev() {
      if (this.isTransitioning) return;

      this.isTransitioning = true;
      this.currentIndex--;
      this.updatePosition(true);

      if (this.currentIndex < this.imageCount) {
        setTimeout(() => {
          this.currentIndex = this.imageCount * 2 - 1;
          this.updatePosition(false);
        }, 500);
      }
    }

    handleNext() {
      this.goToNext();
      this.restartAutoPlay();
    }

    handlePrev() {
      this.goToPrev();
      this.restartAutoPlay();
    }

    startAutoPlay() {
      this.stopAutoPlay();
      if (this.autoPlayInterval > 0 && this.isInViewport) {
        this.autoPlayTimer = setInterval(
          () => this.goToNext(),
          this.autoPlayInterval
        );
      }
    }

    stopAutoPlay() {
      if (this.autoPlayTimer) {
        clearInterval(this.autoPlayTimer);
        this.autoPlayTimer = null;
      }
    }

    restartAutoPlay() {
      this.stopAutoPlay();
      this.startAutoPlay();
    }

    waitForImagesAndStart() {
      const images = Array.from(this.track.querySelectorAll("img"));

      Promise.all(
        images.map((img) =>
          img.complete
            ? Promise.resolve()
            : new Promise((resolve) => {
                img.onload = () => resolve(null);
                img.onerror = () => resolve(null);
              })
        )
      ).then(() => {
        this.updatePosition(false);
        this.startAutoPlay();
      });
    }
  }

  new ImageGalleryCarousel("image-gallery-container", {
    autoPlayInterval: autoPlayInterval,
  });
</script>
<script>
  /* @ts-nocheck */
  // Classify ultra-wide images after load so mobile rules can apply
  document.addEventListener("DOMContentLoaded", () => {
    const container = document.getElementById("image-gallery-container");
    if (!container) return;
    const imgs = container.querySelectorAll(".gallery-item img");
    imgs.forEach((el) => {
      if (!(el instanceof HTMLImageElement)) return;
      const tryMark = () => {
        const item = el.closest(".gallery-item");
        if (!item || !el.naturalWidth || !el.naturalHeight) return;
        const ratio = el.naturalWidth / el.naturalHeight;
        if (ratio > 2.1) item.classList.add("wide");
      };
      if (el.complete) tryMark();
      else {
        el.addEventListener("load", tryMark, { once: true });
        el.addEventListener("error", () => {}, { once: true });
      }
    });
  });
</script>
